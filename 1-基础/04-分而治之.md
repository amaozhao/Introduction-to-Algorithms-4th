# 分而治之

分而治之法是设计渐近高效算法的有力策略。 在学习归并排序时，我们在 2.3.1 节中看到了一个分而治之的例子。 在本章中，我们将探索分而治之法的应用，并获得有价值的数学工具，您可以使用这些工具来解决分析分而治之算法时出现的递归问题。
回想一下，对于分而治之，您递归地解决给定的问题（实例）。 如果问题足够小（基本情况），您只需直接解决它而无需递归。 否则——递归情况——你执行三个特征步骤：
将问题**分成一个或多个子问题**，这些子问题是同一问题的较小实例。

通过**递归解决**子问题来征服它们。

**组合子问题**的解决方案以形成原始问题的解决方案。

分而治之算法将大问题分解为更小的子问题，这些子问题本身可以分解为更小的子问题，等等。 当递归达到基本情况并且子问题足够小可以直接解决而无需进一步递归时递归触底。

### 复发

要分析递归分治算法，我们需要一些数学工具。 递归是一个方程，它根据函数对其他参数（通常较小的参数）的值来描述函数。 递归与分治法密切相关，因为它们为我们提供了一种自然的方式来从数学上描述递归算法的运行时间。 在我们分析合并排序的最坏情况运行时间时，您在 2.3.2 节中看到了一个重复的例子。
对于第 4.1 节和第 4.2 节中介绍的分而治之矩阵乘法算法，我们将推导出描述最坏情况运行时间的递归。 要理解为什么这两种分而治之的算法以它们的方式执行，您需要学习如何解决描述其运行时间的递归。 第 4.3–4.7 节介绍了几种解决递归问题的方法。 这些部分还探讨了递归背后的数学原理，这可以让您更直观地设计自己的分而治之算法。
我们希望尽快了解算法。 所以，我们现在只介绍一些递归的基础知识，然后在看到矩阵乘法示例后，我们将更深入地研究递归，尤其是如何解决它们。
递归的一般形式是方程或不等式，它使用函数本身描述整数或实数上的函数。 它包含两个或多个案例，具体取决于论点。 如果一个案例涉及对不同（通常较小）输入的函数的递归调用，则它是一个递归案例。 如果一个案例不涉及递归调用，它就是一个基本案例。 可能有零个、一个或多个函数满足循环语句。 如果至少有一个函数满足它，则递归定义明确，否则定义不明确。

### 算法重复

我们将对描述分而治之算法运行时间的递归特别感兴趣。 如果对于每个足够大的阈值常数 $n_{0} > 0$，以下两个属性成立，则递归 T (n) 是算法的：

1. 对于所有 $n < n_{0}$，我们有 $T (n) = Θ(1)$。
2. 对于所有 $n \ge n_{0}$，每条递归路径在有限次数的递归调用中终止于定义的基本情况。

类似于我们有时如何滥用渐近符号（请参阅第 60 页），当未为所有参数定义函数时，我们理解此定义受限于定义 T (n) 的 n 值。
为什么表示（正确的）分而治之算法的最坏情况运行时间的递归 T (n) 满足所有足够大的阈值常量的这些属性？ 第一个属性表示存在常数 $c_{1}$、$c_{2}$ 使得 $0 < c_{1} ≤ T (n) ≤ c_{2}$ 对于 $n < n_{0}$。 对于每个合法输入，算法必须在有限时间内输出它正在解决的问题的解决方案（参见第 1.1 节）。 因此我们可以让 $c_{1}$ 是调用过程和从过程返回的最短时间量，它必须是正的，因为需要执行机器指令来调用过程。 如果没有那个大小的合法输入，则算法的运行时间可能不会为某些 n 值定义，但必须至少为一个定义，否则“算法”不能解决任何问题。 因此，我们可以令 $c_{2}$ 为算法在任何大小为 $n < n_{0}$ 的输入上的最大运行时间，其中 $n_{0}$ 足够大，算法至少可以解决一个大小小于 $n_{0}$ 的问题。 最大值是明确定义的，因为最多有有限数量的大小小于 $n_{0}$ 的输入，如果 $n_{0}$ 足够大，则至少有一个。 因此，T (n) 满足第一个属性。 如果第二个属性对于 T (n) 不成立，则该算法不正确，因为它将以无限递归循环结束，或者无法计算出解决方案。 因此，按理说，正确的分而治之算法的最坏情况运行时间的递归将是算法性的。

### 重复约定

我们采用以下约定：

> 每当在没有明确基本情况的情况下陈述递归时，我们假设递归是算法性的。

这意味着您可以为 $T (n) = Θ(1)$ 的基本情况范围自由选择任何足够大的阈值常数 $n_{0}$。 有趣的是，您在分析算法时可能会看到的大多数算法递归的渐近解不依赖于阈值常数的选择，只要它足够大以明确递归。
当我们降低定义在整数上的递归中的任何地板或天花板以将其转换为定义在实数上的递归时，算法分而治之递归的渐近解也不会改变。 第 4.7 节给出了忽略下限和上限的充分条件，适用于您可能会看到的大多数分而治之的循环。 因此，我们经常说没有下限和上限的算法循环。 这样做通常会简化递归语句，以及我们对它们进行的任何数学运算。
有时您可能会看到递归式不是方程式，而是不等式，例如 $T (n) ≤ 2T (n/2) + Θ(n)$。 因为这样的递归仅说明 T (n) 的上限，所以我们使用 O 符号而不是 Θ 符号来表达其解决方案。 类似地，如果不等式反转为 $T (n) ≥ 2T (n/2) + Θ(n)$，那么，因为递推仅给出 $T (n)$ 的下界，我们在其解中使用 Ω 符号。
分而治之和递归

本章通过介绍和使用递归来分析用于乘法 n × n 矩阵的两种分而治之算法，从而说明分而治之法。 4.1 节介绍了一种简单的分而治之算法，该算法通过将大小为 n 的矩阵乘法问题分解为大小为 n/2 的四个子问题来求解，然后递归求解。 算法的运行时间可以用递归来表征
$$
T (n) = 8T (n/2) + Θ(1)
$$
结果得到解 $T (n) = Θ(n^{3})$。 虽然这种分而治之算法并不比使用三重嵌套循环的直接方法快，但由于 V. Strassen，它导致渐近更快的分而治之算法，我们将在第 4.2 节中探讨。 Strassen 非凡的算法将一个大小为 n 的问题分成七个大小为 n/2 的子问题，并递归求解。 Strassen 算法的运行时间可以用递归来描述

$$
T (n) = 7T (n/2) + Θ(n2),
$$
其解为 $T (n) = Θ(n^{lg 7}) = O(n^{2.81})$。 Strassen 的算法渐近地击败了简单的循环方法。
这两种分而治之算法都将一个大小为 n 的问题分解为多个大小为 n/2 的子问题。 尽管对所有子问题使用相同大小的分而治之法很常见，但情况并非总是如此。 有时将大小为 n 的问题划分为不同大小的子问题会很有成效，然后用描述运行时间的递归来反映这种不规则性。 例如，考虑一种分而治之算法，它将大小为 n 的问题分成一个大小为 n/3 的子问题和另一个大小为 2n/3 的子问题，用 $Θ(n)$ 时间来划分问题并将解决方案组合到 子问题。 那么算法的运行时间可以用递归来描述
$$
T (n) = T (n/3) + T (2n/3) + Θ(n)
$$
结果证明有解决方案 $T (n) = Θ(n lg n)$。 我们甚至会在第 9 章中看到一个算法，该算法通过递归地求解一个大小为 n/5 的子问题和另一个大小为 7n/10 的子问题来解决大小为 n 的问题，分解和组合步骤花费 $Θ(n)$ 时间。 其性能满足递归

$$
T (n) = T (n/5) + T (7n/10) + Θ(n)
$$
其解 $T (n) = Θ(n)$。
尽管分而治之算法通常会创建大小为原始问题大小的常数分数的子问题，但情况并非总是如此。 例如，线性搜索的递归版本（见练习 2.1-4）只创建一个子问题，其中一个元素比原始问题少。 每次递归调用都需要常数时间加上递归解决少一个元素的子问题的时间，导致递归
$$
T (n) = T (n – 1) + Θ(1)
$$
其解 $T (n) = Θ(n)$。 然而，绝大多数有效的分而治之算法解决的子问题是原始问题大小的常数部分，这是我们将集中精力的地方。

### 解决复发

在第 4.1 节和第 4.2 节学习了矩阵乘法的分而治之算法后，我们将探索几种解决递归问题的数学工具——即，获得其解的渐近 $Θ-$、$O-$ 或 $Ω$ 界。 我们需要简单易用的工具来处理最常见的情况。 但我们也希望通用工具能够在不太常见的情况下工作，也许需要付出更多的努力。 本章提供了四种解决递归的方法：

- 在代入法（第 4.3 节）中，您猜测边界的形式，然后使用数学归纳法证明您的猜测正确并求解常数。 这种方法可能是解决递归问题最稳健的方法，但它也需要您做出正确的猜测并产生归纳证明。

- 递归树方法（第 4.4 节）将递归建模为一棵树，其节点表示在递归的各个级别发生的成本。 要解决重复问题，您可以确定每个级别的成本并将它们相加，可能使用第 A.2 节中的边界求和技术。 即使您不使用此方法正式证明边界，它也有助于猜测用于替换方法的边界形式。

- master方法（第 4.5 和 4.6 节）是最简单的方法，如果适用的话。 它为形式的重复提供界限
  $$
  T(n) = aT(n/b) + f(n)
  $$
  其中 a > 0 和 b > 1 是常数，f (n) 是给定的“驱动”函数。 与其他任何算法相比，这种类型的重复在算法研究中往往更频繁地出现。 它描述了一种创建子问题的分而治之算法，每个子问题都是原始问题大小的 1/b 倍，使用 f (n) 时间进行划分和合并步骤。 要应用 master 方法，您需要记住三种情况，但一旦记住，您就可以轻松确定许多分而治之算法的运行时间的渐近界。
  
- Akra-Bazzi 方法（第 4.7 节）是解决分而治之递归问题的通用方法。 虽然它涉及微积分，但它可以用来解决比 master 方法处理的更复杂的递归问题。

## 4.1 方阵相乘

我们可以使用分而治之的方法来乘方阵。 如果您以前见过矩阵，那么您可能知道如何将它们相乘。 （否则，您应该阅读 D.1 节。）令 $A = (a_{ik})$ 和 $B = (b_{jk})$为 n × n 方阵。 矩阵乘积 $C = A · B$ 也是一个 n × n 矩阵，其中对于 i, j = 1, 2, … , n，C 的 (i, j) 条目由下式给出
$$
c_{ij}=\sum_{k=1}^{n}a_{ik}\cdot b_{jk} 
$$
通常，我们假设矩阵是密集的，这意味着大多数 $n^{2}$ 条目不是 0，而不是稀疏的，其中大多数 $n^{2}$ 条目是 0 并且非零条目可以比 n × n 阵列。
计算矩阵 C 需要计算 $n^{2}$ 个矩阵项，每个项都是 A 和 B 的输入元素的 n 对乘积之和。MATRIX-MULTIPLY 过程以直接的方式实现该策略，并且它稍微概括了问题。 它以三个 n × n 矩阵 A、B 和 C 作为输入，并将矩阵乘积 A · B 与 C 相加，将结果存储在 C 中。因此，它计算 C = C + A · B，而不仅仅是 C = A · B。如果只需要乘积A · B，则在调用过程之前将C 的$n^{2}$ 个条目全部初始化为0，这将额外花费$Θ(n^{2})$ 的时间。 我们将看到矩阵乘法的成本渐近地支配了这个初始化成本。

```
MATRIX-MULTIPLY(A, B, C, n)
for i = 1 to n                           // compute entries in each of n rows
    for j = 1 to n                       // compute n entries in row i
        for k = 1 to n
            cij = cij + aik · bkj        // add in another term of equation (4.1)
```

MATRIX-MULTIPLY 的伪代码工作如下。 第 1-4 行的 for 循环计算每一行 i 的条目，在给定行 i 内，第 2-4 行的 for 循环计算每一列 j 的每个条目 $c_{ij}$。 第 3-4 行的 for 循环的每次迭代都会在等式 (4.1) 中增加一项。
因为每个三重嵌套的 for 循环运行恰好 n 次迭代，并且第 4 行的每次执行都需要常数时间，所以 MATRIX-MULTIPLY 过程在 $Θ(n^{3})$ 时间内运行。 即使我们加上将 C 初始化为 0 的 $Θ(n^{2})$ 时间，运行时间仍然是 $Θ(n^{3})$。
一个简单的分而治之算法

让我们看看如何使用分治法计算矩阵乘积 A · B。 对于 n > 1，除法步骤将 n × n 矩阵划分为四个 n/2 × n/2 子矩阵。 我们假设 n 是 2 的精确幂，因此随着算法的递归，我们可以保证子矩阵的维数是整数。 （练习 4.1-1 要求你放宽这个假设。）与 MATRIX-MULTIPLY 一样，我们实际上会计算 C = C + A · B。但是为了简化算法背后的数学运算，我们假设 C 已经被初始化为 零矩阵，所以我们确实在计算 C = A · B。
除法步骤将 n × n 矩阵 A、B 和 C 中的每一个视为四个 n/2 × n/2 子矩阵：
$$
A = \binom{A_{11}\ A_{12}}{A_{21}\ A_{22}} \ \ 
B = \binom{B_{11}\ B_{12}}{B_{21}\ B_{22}} \ \
C = \binom{C_{11}\ C_{12}}{C_{21}\ C_{22}}
$$
那么我们可以将矩阵乘积写为
$$
\begin{pmatrix}
 C_{11} & C_{12}\\
 C_{21} & C_{22}
\end{pmatrix} = \begin{pmatrix}
 A_{11} & A_{12}\\
 A_{21} & A_{22}
\end{pmatrix} \ \begin{pmatrix}
 B_{11} & B_{12}\\
 B_{21} & B_{22}
\end{pmatrix} = \begin{pmatrix}
 A_{11}\cdot B_{11}+A_{12}\cdot B_{21} & A_{11}\cdot B_{12}+A_{12}\cdot B_{22}\\
 A_{21}\cdot B_{11}+A_{22}\cdot B_{21} & A_{21}\cdot B_{12}+A_{22}\cdot B_{22}
\end{pmatrix}
$$
对应于方程
$$
C_{11} = A_{11}\cdot B_{11}+A_{12}\cdot B_{21}
$$
$$
C_{12} = A_{11}\cdot B_{12}+A_{12}\cdot B_{22}
$$
$$
C_{21} = A_{21}\cdot B_{11}+A_{22}\cdot B_{21}
$$
$$
C_{22} = A_{21}\cdot B_{12}+A_{22}\cdot B_{22}
$$

等式 (4.5)–(4.8) 涉及八次 n/2 × n/2 乘法和四次 n/2 × n/2 子矩阵加法。
当我们希望将这些方程式转换为可以用伪代码描述甚至实际实现的算法时，有两种常见的方法可以实现矩阵划分。
一种策略是分配临时存储来保存 A 的四个子矩阵 $A_{11}$、$A_{12}$、$A_{21}$ 和 $A_{22}$ 以及 B 的四个子矩阵 $B_{11}$、$B_{12}$、$B_{21}$ 和 $B_{22}$。 然后将 A 和 B 中的每个元素复制到相应子矩阵中的相应位置。 在递归征服步骤之后，将 C 的四个子矩阵 $C_{11}$、$C_{12}$、$C_{21}$ 和 $C_{22}$ 中的每个元素复制到它们在 C 中的相应位置。这种方法需要 $Θ(n^{2})$ 时间，因为复制了 $3n^{2}$ 个元素。
第二种方法使用指数计算，速度更快，更实用。 可以通过指示子矩阵在矩阵中的位置而不触及任何矩阵元素来在矩阵中指定子矩阵。 划分矩阵（或递归地，子矩阵）仅涉及对该位置信息的算术运算，该位置信息具有独立于矩阵大小的恒定大小。 对子矩阵元素的更改会更新原始矩阵，因为它们占用相同的存储空间。
展望未来，我们将假设使用索引计算并且可以在 Θ(1) 时间内执行分区。 练习 4.1-3 要求你证明矩阵乘法的整体渐近运行时间没有区别，但是矩阵的划分是使用第一种复制方法还是第二种索引计算方法。 但是对于其他的分治矩阵计算，例如矩阵加法，它会有所不同，正如练习 4.1-4 要求你展示的那样。
MATRIX-MULTIPLY-RECURSIVE 过程使用等式 (4.5)–(4.8) 来实现方阵乘法的分而治之策略。 与 MATRIX-MULTIPLY 一样，MATRIX-MULTIPLY-RECURSIVE 过程计算 C = C + A · B，因为如果需要，可以在调用过程之前将 C 初始化为 0，以便仅计算 C = A · B。

```
MATRIX-MULTIPLY-RECURSIVE(A, B, C, n)

if n == 1
// Base case.
    c11 = c11 + a11 · b11
    return
Divide.
partition A, B, and C into n/2 × n/2 submatrices
A11, A12, A21, A22; B11, B12, B21, B22;
and C11, C12, C21, C22; respectively

// Conquer.
MATRIX-MULTIPLY-RECURSIVE(A11, B11, C11, n/2)
MATRIX-MULTIPLY-RECURSIVE(A11, B12, C12, n/2)
MATRIX-MULTIPLY-RECURSIVE(A21, B11, C21, n/2)
MATRIX-MULTIPLY-RECURSIVE(A21, B12, C22, n/2)
MATRIX-MULTIPLY-RECURSIVE(A12, B21, C11, n/2)
MATRIX-MULTIPLY-RECURSIVE(A12, B22, C12, n/2)
MATRIX-MULTIPLY-RECURSIVE(A22, B21, C21, n/2)
MATRIX-MULTIPLY-RECURSIVE(A22, B22, C22, n/2)
```

当我们遍历伪代码时，我们将派生一个循环来描述它的运行时间。 令 $T (n)$ 为使用此过程将两个 n × n 矩阵相乘的最坏情况时间。
在基本情况下，当 n = 1 时，第 3 行仅执行一次标量乘法和一次加法，这意味着 $T (1) = Θ(1)$。 正如我们对常量基本情况的约定，我们可以在递归语句中省略这个基本情况。
递归情况发生在 n > 1 时。如前所述，我们将在第 6 行中使用索引计算来划分矩阵，花费 $Θ(1)$ 时间。 第 8–15 行递归调用 MATRIX-MULTIPLY-RECURSIVE 总共八次。 前四个递归调用计算方程 (4.5)–(4.8) 的第一项，随后的四个递归调用计算并添加第二项。 由于索引计算，每次递归调用都会将 A 的子矩阵和 B 的子矩阵的乘积添加到适当的 C 子矩阵中。 因为每次递归调用都将两个 n/2 × n/2 矩阵相乘，从而为总运行时间贡献了 $T(n/2)$，所以所有八次递归调用所花费的时间都是 $8T(n/2)$。 没有组合步骤，因为矩阵 C 已就地更新。 因此，递归情况的总时间是分区时间与所有递归调用时间的总和，即 $Θ(1) + 8T (n/2)$。
因此，省略基本情况的陈述，我们对 MATRIX-MULTIPLY-RECURSIVE 运行时间的递归是
$$
T(n) = 8T (n/2) + Θ(1)
$$
正如我们将从 4.5 节的 master 方法中看到的，递归 (4.9) 的解为 $T (n) = Θ(n^{3})$，这意味着它与直接的 MATRIX-MULTIPLY 过程具有相同的渐近运行时间。
为什么此递归的 Θ(n3) 解比第 41 页的合并排序递归 (2.3) 的 $Θ(n lg n)$ 解大得多？ 毕竟，合并排序的递归包含 $Θ(n)$ 项，而递归矩阵乘法的递归仅包含 $Θ(1)$ 项。
让我们考虑一下递归的递归树 (4.9) 与合并排序的递归树相比会是什么样子，如第 43 页的图 2.5 所示。合并排序递归中的因子 2 决定了每个树节点有多少子节点 有，这又决定了有多少项对树的每个级别的总和有贡献。 相比之下，对于 MATRIX-MULTIPLY-RECURSIVE 的递归 (4.9)，递归树中的每个内部节点都有八个子节点，而不是两个，这导致具有更多叶子的“更密集”的递归树，尽管内部节点 每个都小得多。 因此，递归 (4.9) 的解比递归 (2.3) 的解增长得更快，这在实际解中得到了证实：$Θ(n3)$ 与 $Θ(n lg n)$。

### 练习

注意：在尝试其中一些练习之前，您可能希望阅读第 4.5 节。
**4.1-1** 推广 MATRIX-MULTIPLY-RECURSIVE 以乘以 n × n 矩阵，其中 n 不一定是 2 的精确幂。给出描述其运行时间的递归。 认为它在最坏情况下运行在 $Θ(n^{3})$ 时间内。
**4.1-2** 使用 MATRIX-MULTIPLY-RECURSIVE 作为子例程，将 k n × n 矩阵（k n 行和 n 列）乘以 n × k n 矩阵（其中 k ≥ 1）的速度有多快？ 回答关于将 n × k n 矩阵乘以 k n × n 矩阵的相同问题。 哪个渐近更快，快多少？
**4.1-3** 假设在 MATRIX-MULTIPLY-RECURSIVE 中不是通过索引计算来划分矩阵，而是将 A、B 和 C 的适当元素复制到单独的 $n/2 × n/2$ 子矩阵 $A_{11}$、$A_{12}$、$A_{21}$、$A_{22}$ 中； $B_{11}$、$B_{12}$、$B_{21}$、$B_{22}$； 和$_{C11}$，$C_{12}$，$C_{21}$，$C_{22}$，分别。 递归调用后，将 $C_{11}$、$C_{12}$、$C_{21}$ 和 $C_{22}$ 的结果复制回 C 中适当的位置。递归（4.9）如何变化，它的解决方案是什么？
**4.1-4** 为分治算法 MATRIX-ADD-RECURSIVE 编写伪代码，该算法通过将两个 n × n 矩阵 A 和 B 划分为四个 $n/2 × n/2$ 子矩阵，然后递归地对相应的子矩阵对求和来对两个 $n × n$ 矩阵 A 和 B 求和。 假设矩阵划分使用 $Θ(1)$ 时间索引计算。 为 MATRIX-ADD-RECURSIVE 的最坏情况运行时间写一个递归，并解决你的递归。 如果使用 $Θ(n^{2})$ 次复制来实现分区而不是索引计算，会发生什么情况？

## 4.2 矩阵乘法的施特拉森算法

您可能会发现很难想象任何矩阵乘法算法都可以花费少于 $Θ(n^3)$ 的时间，因为矩阵乘法的自然定义需要 $n^3$ 次标量乘法。 实际上，直到 1969 年 V. Strassen [424] 发表了一个出色的 $n × n$ 矩阵乘法递归算法时，许多数学家才认为不可能在 $o(n^3)$ 时间内乘以矩阵。 Strassen 的算法运行时间为 $Θ(n^{lg7})$。 由于 $lg7 = 2.8073549 …$，Strassen 算法的运行时间为 $O(n^{2.81})$，渐近优于 $Θ(n^3)$ MATRIX-MULTIPLY 和 MATRIX-MULTIPLY-RECURSIVE 过程。
Strassen 方法的关键是使用 MATRIX-MULTIPLY-RECURSIVE 过程中的分而治之的思想，但使递归树不那么稠密。 实际上，我们会将每个分法和合并步骤的工作增加一个常数因子，但减少繁琐会得到回报。 我们不会减少从递归的八向分支（4.9）一直到递归的双向分支（2.3）的繁琐，但我们会稍微改进它，这将产生很大的影响 不同之处。 Strassen 的算法不是对 $n/2 × n/2$ 矩阵执行八次递归乘法，而是只执行七次。 消除一次矩阵乘法的代价是对 $n/2 × n/2$ 矩阵进行几次新的加减运算，但仍然只是一个常数。 我们不会到处都说“加法和减法”，而是采用将它们都称为“加法”的通用术语，因为减法在结构上与加法的计算相同，只是符号发生了变化。
